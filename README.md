# BinLing (BLE): Deterministic Agent Control via Geometric Latent Space

> **"English is too fuzzy for physics. We need an Agent that thinks in Assembly."**

**[Green Swarm Visualization]** 

*(Self-Replicating Swarm Probe generated by Qwen 2.5 and executed in BinLing VM)*

## üî¨ The Experiment
Standard AI Agents rely on "Chain of Thought" (CoT) in natural language to execute tasks. This works for emails but fails for autonomous control because English is high-entropy and prone to hallucination. 

**BinLing** proves that by constraining an LLM's latent space to a low-fertility instruction set, we can achieve **deterministic, physics-compliant behavior**.

**The Stack:**
* **Intelligence:** Qwen 2.5 7B (acting as a Compiler).
* **Bridge:** Python Driver enforcing strict schema constraints.
* **Physics:** Custom Rust Virtual Machine (`binling_cli`) managing a 3D Polytope Lattice.
* **Visualization:** WebAssembly (WASM) Real-time Renderer.

## üìä The Findings: "The Tokenizer Tax"
During our v0.1 benchmarks, we observed a critical distinction between **Token Efficiency** and **Execution Density**.

| Metric | Natural Language Input | BinLing ASM Output |
| :--- | :--- | :--- |
| **Content** | "Create a self-replicating swarm..." | `LOAD 0 0 0 80 REPL 1 0 0...` |
| **Length** | 287 Bytes | 134 Bytes |
| **Token Count** | **80 Tokens** | **86 Tokens** |
| **Reliability** | Probabilistic (Might fail) | **100% Deterministic** |

**Insight:** While modern tokenizers are biased toward English (making ASM appear "expensive" in token count), the **Byte Density** of the executed logic is **6x higher**. We trade token efficiency for execution safety.

## üõ†Ô∏è Components
* **`core/`**: The Rust Reference VM (Lattice Scheduler, Levin Method).
* **`cli/`**: The Assembler and Runtime Environment.
* **`interface/`**: The "Oracle" text files used to bridge Python and Rust.
* **`spec/`**: Authoritative definitions of the Encoding and Scheduling.

## üöÄ How to Replicate
1.  **Boot the VM:**
    ```bash
    cargo run -p binling_cli --bin binling_cli
    ```
2.  **Run the Benchmark:**
    ```bash
    # Runs the physics engine benchmark (approx 600¬µs per genesis cycle)
    cargo bench -p binling_core --features cli-mode
    ```
3.  **Inject Intent:**
    Use the Python driver (or edit `interface/oracle_in.txt` manually) to inject BinLing Assembly.

## üìú Roadmap & Status
* [x] **Reference VM:** Rust implementation of the Lattice Scheduler.
* [x] **Levin Method:** Active/Next queue scheduling implemented.
* [x] **Assembly Bridge:** Text-to-Bytecode compiler (CLI).
* [ ] **Visual Tokenization:** Mapping opcodes to single pixels (v2.0).

## License
MIT License - Open Source for the advancement of Deterministic AI.
